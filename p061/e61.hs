-- Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers
-- are all figurate (polygonal) numbers and are generated by the following
-- formulae:
--     Triangle        P3,n=n(n+1)/2       1, 3, 6, 10, 15, ...
--     Square          P4,n=n2             1, 4, 9, 16, 25, ...
--     Pentagonal      P5,n=n(3n−1)/2      1, 5, 12, 22, 35, ...
--     Hexagonal       P6,n=n(2n−1)        1, 6, 15, 28, 45, ...
--     Heptagonal      P7,n=n(5n−3)/2      1, 7, 18, 34, 55, ...
--     Octagonal       P8,n=n(3n−2)        1, 8, 21, 40, 65, ...
--
-- The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
-- interesting properties.
--
--     - The set is cyclic, in that the last two digits of each number is the
--       first two digits of the next number (including the last number with
--       the first).
--     - Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and
--       pentagonal (P5,44=2882), is represented by a different number in the
--       set.
--     - This is the only set of 4-digit numbers with this property.
--
-- Find the sum of the only ordered set of six cyclic 4-digit numbers for which
-- each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal,
-- and octagonal, is represented by a different number in the set.

import Data.List

-- Polygonal numbers
triangle n = n * (n + 1) `div` 2
square n = n * n
pentagonal n = n * (3*n - 1) `div` 2
hexagonal n = n * (2*n - 1)
heptagonal n = n * (5*n - 3) `div` 2
octagonal n = n * (3*n - 2)

-- 4 digit cyclic numbers
fourPolys fn = takeWhile (\ n -> n <= 9999) $
               dropWhile (\ n -> n <= 1000) $
               map fn [1..]
four Triangle = fourPolys triangle
four Square = fourPolys square
four Pentagon = fourPolys pentagonal
four Hexagon = fourPolys hexagonal
four Heptagon = fourPolys heptagonal
four Octagon = fourPolys octagonal

-- "Polygon Sets"
tailDigits n = n `mod` 100
headDigits n = n `div` 100

nextNs n ns = [ m | m <- ns, tailDigits n == headDigits m ]
nextP n p = nextNs n $ four p

data Polygon = Triangle | Square | Pentagon | Hexagon | Heptagon | Octagon
               deriving (Show,Eq,Enum,Ord)
type PolySet = [(Int,Polygon)]

notInSet ps = filter (not . inSet) [Triangle .. Octagon]
    where inSet p = p `elem` polys
          polys = map snd ps

extend ps = do
    poly <- notInSet ps
    let (n, _) = head ps
    next <- nextP n poly
    return ((next, poly) : ps)

-- Solution
loop ps = t == h
    where t = tailDigits $ fst $ head ps
          h = headDigits $ fst $ last ps

e61 = do
    p <- [Triangle .. Octagon]
    n <- four p
    let e = extend [(n,p)] >>= extend >>= extend >>= extend >>= extend
    filter loop e

main = print $ sum $ map fst $ head e61
